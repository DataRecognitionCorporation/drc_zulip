#!/usr/bin/env groovy

@Library('DRC_Global_Pipeline_Libraries@master')

IS_DEV = true
ACCOUNT_NUM = null

def credentials = drc_AwsAssumeRoleAsEnv([
  [account_number: '911870898277', region: 'us-east-2'],
  [account_number: '333509430799', region: 'us-east-2']
])

pipeline {
  environment {
    WORKING_DIR = "frontend"
    APP_NAME = 'Zulip'
    REGION = 'us-east-2'
  }
  agent {
    kubernetes(
      drc_k8_agent(templates: [
        [name: 'terraform', isDefault: true]
      ])
    )
  }

  options {
    buildDiscarder(logRotator(daysToKeepStr: '3', artifactDaysToKeepStr: '3'))
    ansiColor('xterm')
  }

  parameters {
    choice(choices: ['dev'], description: 'Deploy to le or prod?', name: 'ENVIRONMENT')
    choice(choices: [true, false], description: 'Dry run (tf plan) or deploy (tf apply)?', name: 'DRYRUN')
  }

  stages {
    stage ('Configure') {
      steps {
        script {
          if (params.ENVIRONMENT == 'prod') {
            IS_DEV = false
            ACCOUNT_NUM = 911870898277
          } else {
            IS_DEV = true
            ACCOUNT_NUM = 333509430799
          }
          println(IS_DEV)


        }
      }
    }
    stage ('Dev Apply') {
      when {
        // branch 'infrastructure'
        expression { IS_DEV }
      }
      steps {
        dir("${WORKSPACE}/${env.WORKING_DIR}") {

          script {
            whithEnv(credentials[ACCOUNT_NUM]) {
              deploy_perm([name: "dev", dryRun: params.DRYRUN, region: env.REGION, account_num: ACCOUNT_NUM])

              sh 'aws sts get-caller-identity'
              sh "make plan env=${params.ENVIRONMENT}"
              sh "make apply env=${params.ENVIRONMENT}"
            }
          }
        }
      }
    }
    stage ('Prod') {
      when {
        branch 'infrastructure'
        expression { !IS_DEV }
      }
      steps {
        script {
          drc_AwsAssumeRole([jenkinsRole: 'cloud-build-jenkins-role', region: env.REGION, acctNum: ACCOUNT_NUM, appName: "${env.APP_NAME}", bldNum : "${BUILD_NUMBER}", timeout: 3600])

          def tiers = [
            [name: "prod", askForPermission: true, dryRun: params.DRYRUN, region: env.REGION, account_num: ACCOUNT_NUM]
          ]
          def terraformTasksToExec = generateTerraformTasks tiers

          terraformTasksToExec.each { k, v -> v() }
        }
      }
    }
  }
}

def deploy_perm(def tier) {
  def result = 'SUCCESS'
  if(tier.dry_run == false) {
    result = drc_AskForPermissionSkip([
      name     : "Deploy ${env.APP_NAME} ${tier.region} to ${tier.name}",
      to_time  : 10,
      to_unit  : 'MINUTES',
      id       : "${env.APP_NAME}-${tier.region}",
      message  : "Deploy ${env.APP_NAME} ${tier.region} to ${tier.name} or abort?",
      submitter: "pnambiar,grees,nkovalenko,bpoush,tjensen,atormanen,jwdunn"
    ])
  }

  if (result == 'ABORTED') {
    println('pipeline aborted')
    currentBuild.result = 'ABORTED'
    error("Aborting the build.")
  } else if (result == 'SKIPPED') {
    echo "SKIP"
  } else {
    println("${tier.name} ${region}")
    if (tier.dry_run == false) {
      println('apply')
      //sh "make apply env=${tier.name}"
    }
  }
}
