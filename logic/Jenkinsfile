#!/usr/bin/env groovy

@Library('DRC_Global_Pipeline_Libraries@master')

IS_DEV = true
ACCOUNT_NUM = null

pipeline {
  environment {
    WORKING_DIR = "logic"
    APP_NAME = 'Zulip'
  }
  agent {
    kubernetes(
      drc_k8_agent(templates: [
        [name: 'terraform', isDefault: true]
      ])
    )
  }

  options {
    buildDiscarder(logRotator(daysToKeepStr: '3', artifactDaysToKeepStr: '3'))
    ansiColor('xterm')
  }

  parameters {
    choice(choices: ['dev'], description: 'Deploy to le or prod?', name: 'ENVIRONMENT')
    choice(choices: ['true', 'false'], description: 'Dry run (tf plan) or deploy (tf apply)?', name: 'DRYRUN')
    choice(choices: ['us-east-2', 'us-east-1'], description: 'aws region to deploy to.', name: 'REGION')
  }

  stages {
    stage ('Configure') {
      steps {
        script {
          if (params.ENVIRONMENT == 'prod') {
            IS_DEV = false
            ACCOUNT_NUM = 911870898277
          } else {
            IS_DEV = true
            ACCOUNT_NUM = 333509430799
          }
          println(IS_DEV)
        }
      }
    }
    stage ('Dev Apply') {
      when {
        // branch 'infrastructure'
        expression { IS_DEV }
      }
      steps {
        script {
          drc_AwsAssumeRole([jenkinsRole: 'cloud-build-jenkins-role', region: params.REGION, acctNum: ACCOUNT_NUM, appName: "${env.APP_NAME}", bldNum : "${BUILD_NUMBER}", timeout: 3600])
          def tiers = [
            [name: "dev",    , dryRun: params.DRYRUN, region: params.REGION, account_num: ACCOUNT_NUM]
          ]
          def terraformTasksToExec = generateTerraformTasks tiers
          terraformTasksToExec.each { k, v -> v() }
        }
      }
    }
    stage ('Prod') {
      when {
        branch 'infrastructure'
        expression { !IS_DEV }
      }
      steps {
        script {
          drc_AwsAssumeRole([jenkinsRole: 'cloud-build-jenkins-role', region: params.REGION, acctNum: ACCOUNT_NUM, appName: "${env.APP_NAME}", bldNum : "${BUILD_NUMBER}", timeout: 3600])

          def tiers = [
            [name: "prod", askForPermission: true, dryRun: params.DRYRUN, region: params.REGION, account_num: ACCOUNT_NUM]
          ]
          def terraformTasksToExec = generateTerraformTasks tiers

          terraformTasksToExec.each { k, v -> v() }
        }
      }
    }
  }
}

def generateTerraformTasks(def tiers) {
  def tasks = [:]

  tiers.each { tier ->
    def tierShortname = tier.name
    def region = tier.region
    def dryRun = tier.dryRun
    def account_num = tier.account_num

    tasks["${tierShortname}-${region}"] = {

      def result = 'SUCCESS'

      if(!dryRun) {
        result = drc_AskForPermissionSkip([
          name     : "Deploy ${env.APP_NAME} ${region} to ${tierShortname}",
          to_time  : 10,
          to_unit  : 'MINUTES',
          id       : "${env.APP_NAME}-${region}",
          message  : "Deploy ${env.APP_NAME} ${region} to ${tierShortname} or abort?",
          submitter: "pnambiar,grees,nkovalenko,bpoush,tjensen,atormanen,jwdunn"
        ])
      }
     
      if (result == 'ABORTED') {
        println('pipeline aborted')
        currentBuild.result = 'ABORTED'
        error("Aborting the build.")
      } else if (result == 'SKIPPED') {
        echo "SKIP"
      } else {
        stage("${tierShortname}-${region}") {
          println("${tierShortname} ${region}")

          sh 'aws sts get-caller-identity'

          dir("${WORKSPACE}/${env.WORKING_DIR}") {
            sh "make plan env=${tierShortname}"
            if (!dryRun) {
              // sh "make apply env=${tierShortname}"
            }
          }
        }
      }
    }
  }
  return tasks
}